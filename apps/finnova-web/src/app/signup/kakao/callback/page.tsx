'use client';

export const dynamic = 'force-dynamic';

import { useEffect, useRef, useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';

const SIGNUP_FLOW_KEY = 'signup_flow_data';
const KAKAO_JS_KEY = process.env.NEXT_PUBLIC_KAKAO_JS_KEY || process.env.NEXT_PUBLIC_KAKAO_MAP_API_KEY || '';
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:4000/api/v1';
const REDIRECT_URI =
  process.env.NEXT_PUBLIC_KAKAO_SIGNUP_REDIRECT_URI ||
  'http://localhost:3000/signup/kakao/callback';

export default function SignupKakaoCallbackPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [message, setMessage] = useState('카카오 계정 인증 중...');
  // Prevent double-execution in React 18 StrictMode (effects run twice in dev)
  const exchanged = useRef(false);

  useEffect(() => {
    // Guard: Kakao auth codes are single-use. React 18 StrictMode runs effects
    // twice in dev, which would consume the code on the first run and fail on the second.
    if (exchanged.current) return;
    exchanged.current = true;

    const code = searchParams.get('code');
    const error = searchParams.get('error');

    if (error) {
      setStatus('error');
      setMessage('카카오 인증이 취소되었습니다.');
      setTimeout(() => router.replace('/signup/individual/verify'), 2000);
      return;
    }

    if (!code) {
      setStatus('error');
      setMessage('인증 코드를 찾을 수 없습니다.');
      setTimeout(() => router.replace('/signup/individual/verify'), 2000);
      return;
    }

    const exchangeAndStore = async () => {
      try {
        // Exchange code with backend (reuses the existing Kakao auth endpoint)
        const response = await fetch(`${API_URL}/auth/kakao/callback`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code, redirectUri: REDIRECT_URI }),
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error((errorData as any)?.message || '카카오 인증 실패');
        }

        const data = await response.json();
        const user = data?.data?.user;

        if (!user) {
          throw new Error('카카오 프로필 정보를 가져올 수 없습니다');
        }

        // Write Kakao data into the existing signup_flow_data session storage
        const existing = (() => {
          try {
            const raw = sessionStorage.getItem(SIGNUP_FLOW_KEY);
            return raw ? JSON.parse(raw) : { data: {}, currentStep: 2, completedSteps: [] };
          } catch {
            return { data: {}, currentStep: 2, completedSteps: [] };
          }
        })();

        // --- Placeholder generators for fields not returned by Kakao's test/free key ---
        // These are overridden by real values via ?? when the production key provides them.
        const randomPhone = () => {
          const mid = String(Math.floor(Math.random() * 9000) + 1000);
          const end = String(Math.floor(Math.random() * 9000) + 1000);
          return `010${mid}${end}`;
        };
        const randomBirthDate = () => {
          const year = 1970 + Math.floor(Math.random() * 35); // 1970–2005
          const month = String(Math.floor(Math.random() * 12) + 1).padStart(2, '0');
          const day = String(Math.floor(Math.random() * 28) + 1).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        const randomGender = (): 'M' | 'F' => (Math.random() > 0.5 ? 'M' : 'F');

        // From Kakao profile — real data via production key, placeholders via test key
        const kakaoName = user.firstName
          ? [user.firstName, user.lastName].filter(Boolean).join(' ')
          : null;
        // Strip placeholder email generated by our backend for passwordless Kakao users
        const kakaoEmail = user.email?.includes('@kakao.fiscus.app') ? null : user.email ?? null;

        const updatedState = {
          ...existing,
          data: {
            ...existing.data,
            verifiedName:        kakaoName           ?? '카카오사용자',   // nickname from Kakao; fallback label
            verifiedEmail:       kakaoEmail          ?? undefined,         // null → stays editable on step 5
            // Fields below: production Kakao key returns them; test key returns null → use placeholder
            verifiedPhone:       user.phone          ?? randomPhone(),      // 전화번호 (유료 동의항목)
            verifiedBirthDate:   user.birthDate      ?? randomBirthDate(),  // 생년월일 (유료 동의항목)
            verifiedGender:      user.gender         ?? randomGender(),     // 성별 (유료 동의항목)
            verificationMethod:  'kakao',
          },
          completedSteps: Array.from(new Set([...(existing.completedSteps || []), 2])),
        };

        sessionStorage.setItem(SIGNUP_FLOW_KEY, JSON.stringify(updatedState));
        // Backup flags
        localStorage.setItem('signup_step_2_completed', 'true');
        if (updatedState.data.verifiedName) {
          sessionStorage.setItem('verifiedName', updatedState.data.verifiedName);
        }
        if (updatedState.data.verifiedEmail) {
          sessionStorage.setItem('verifiedEmail', updatedState.data.verifiedEmail);
        }

        setStatus('success');
        setMessage('인증 완료! 정보 입력 페이지로 이동합니다...');

        setTimeout(() => router.replace('/signup/individual/info'), 1200);
      } catch (err) {
        console.error('Kakao signup callback error:', err);
        setStatus('error');
        setMessage(err instanceof Error ? err.message : '카카오 인증 처리 중 오류가 발생했습니다');
        setTimeout(() => router.replace('/signup/individual/verify?error=kakao_failed'), 2500);
      }
    };

    exchangeAndStore();
  }, [searchParams, router]);

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '100vh',
        background: 'linear-gradient(to bottom, #eff6ff, #ffffff)',
        fontFamily: 'sans-serif',
      }}
    >
      <div
        style={{
          width: 64,
          height: 64,
          borderRadius: '50%',
          background: status === 'error' ? '#fee2e2' : '#FEE500',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          marginBottom: 20,
          animation: status === 'loading' ? 'pulse 1.4s ease-in-out infinite' : 'none',
        }}
      >
        {status === 'loading' && (
          <svg width="32" height="30" viewBox="0 0 256 238" fill="none">
            <path
              fillRule="evenodd"
              clipRule="evenodd"
              d="M128 0C57.31 0 0 44.776 0 100.032c0 35.355 22.553 66.421 56.671 84.588L44.01 234.344a4 4 0 006.062 4.476l59.232-39.136C115.375 200.877 121.615 201 128 201c70.692 0 128-44.776 128-100.968C256 44.776 198.692 0 128 0z"
              fill="#191600"
            />
          </svg>
        )}
        {status === 'success' && <span style={{ fontSize: 32 }}>✓</span>}
        {status === 'error' && <span style={{ fontSize: 32, color: '#dc2626' }}>✕</span>}
      </div>

      <p
        style={{
          fontSize: 16,
          fontWeight: 600,
          color: status === 'error' ? '#dc2626' : '#1f2937',
          marginBottom: 8,
        }}
      >
        {status === 'loading' ? '카카오 인증 처리 중' : status === 'success' ? '인증 완료' : '인증 실패'}
      </p>
      <p style={{ fontSize: 14, color: '#6b7280' }}>{message}</p>

      <style>{`
        @keyframes pulse {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(0.9); opacity: 0.75; }
        }
      `}</style>
    </div>
  );
}
